# 使用场景

在什么场景下使用NumPy呢？

让我们继续以线性回归为例。（写作备注：前面讲三类分析——描述、预测、因果也会以线性回归为例）线性回归通常情况使用最小二乘法估计参数，让我们先尝试用Python翻译数学表达式，然后尝试用NumPy重构地更简单，从这个简单的例子里窥探NumPy的使用场景。

（这里插入一组数据案例。）

（然后插入线性回归最小二乘法估计的参数结果。）

使用Python写的效果是这样的：

```python
# 输入数据
x: List[float] = []
y: List[float] = []

# 计算X的平均值
x_mean = sum(x)/len(x)
# 计算Y的平均值
y_mean = sum(y)/len(y)

# 计算\beta_1的分子
numerator = 0
for x_i, y_i in zip(x,y):
    numerator += (x_i - x-mean)*(y_i-y_mean)

# 计算\beta_1的分母    
denominator = 0
for x_i in x:
    denominator += (x_i - x_mean)**2
# 计算\beta_1
beta1 = numrator/denominator

# 计算\beta_0
beta0 = y_mean - x_mean*beta1
```

一个只有两个式子的简单需求，需要我们写一二十行Python处理，看起来很繁琐，无论是开发者自己写还是其他人读都比较不直观。如果再复杂一些呢？比如自变量从一维变成N维，岂不是更加繁琐？

因此，我们应当去思考，有没有更简单的方式帮助我们处理呢？

在数学上是可以的，无论是一维还是N维线性回归，都可以用矩阵形式表达成如下形式：

（插入数学公式。）

如果我们有一种工具，可以比较好地支持矩阵计算，岂不是可以在矩阵表达式长什么样子的前提下就可以写出什么样的代码？这样代码行数可以减少到1/5甚至1/10，而且写起来和读起来也更加直观。
“面向数组的编程”很好地解决了这类问题。本文即将介绍的Python库NumPy，以及Matlab、R等同类语言和软件都有相应的设计支持。这里让我们尝试使用NumPy重写：

```python
import numpy as np

# 输入数据
x = np.array([])
y = np.array([])

# 计算beta矩阵
beta = np.linalg.inv(np.mean(x*x.T))*np.mean(x*y)
```

这就完了？是的，一行有效代码就完了，而且每一步操作和矩阵计算完美对应，这就又好写又好读。

因此，面向数组的编程适用于这样的场景，当我们需要批量分步处理而不再写for循环枯燥地一个一个循环处理，特别是在有矩阵的科学计算场景里，以数组为基本数据结构单元、以对数组的操作计算处理逻辑，可以有效提高开发效率、代码可读性，甚至是代码运行效率。
